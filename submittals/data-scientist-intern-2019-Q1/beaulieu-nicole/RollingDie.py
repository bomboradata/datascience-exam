
import random


# This was my first stab at figuring this out.  I realized in doing so that the
# values were not going to be equally distributed since there are many ways to
# get some of the values (ex. 1 + 3 = 4, 2 + 2 = 4, 3 + 1 = 4).
def generate_rng_no_bueno():
    
    # Roll the same die twice.
    roll1 = random.randint(1, 6)
    sum_of_two_rolls = roll1 + random.randint(1, 6)

    # To make this work, we need to check for the bounds of our random number
    # generator.  So, if the first roll is a 1, return it value since the sum of
    # the two rolls will never return 1.
    # Also, since our generator has a max of 7, return the first roll.
    if (roll1 == 1 or sum_of_two_rolls > 7):
        return roll1
    # Otherwise, return the sum.
    else:
        return sum_of_two_rolls

# Next, I wrote this test code to figure out how I could use sections or chunks of
# of the results of two rolls to generate the values within the right range.
# This is the though process that led me to the modulus idea.

# Test code to figure out the algorithm.
# for x in range (2, 36):
#    outcome = x % 7
#    print ("test output: %d" % (outcome))

# Using a single 6-side die, generate a random number between 1 and 7.
def generate_rng():
    
    # Roll the same die twice.  This gives us a range between 2 and 36 that is
    # evenly distributed.  Note that the division is inclusive on the low end
    # and exclusive on the top end.  Of course, in a bigger program,
    # we'd shy away from magic numbers.
    sum_of_two_rolls = random.randint(1, 7) + random.randint(1, 7)

    # Just make sure that the random isn't returning something unexpected.
    if (sum_of_two_rolls < 2):
        print ("Yikes.  < 36")
    if (sum_of_two_rolls > 36):
        print ("Yikes.  > 36")
    
    # Knowing that we want a value between 1 and 7, we can apply the modulus
    # to use the remainder to map our sum to a value between 0 and 6.  Adjust
    # by 1 to get our final value between 1 and 7.
    outcome = sum_of_two_rolls % 7 + 1

    # Show progress.
    #print (outcome, flush=True)
    return outcome


# Run a lot of tests to make sure that there are no errant values and to ensure
# that the values generated are roughly evenly distributed.
test_distribution = [0] * 7
for x in range (1, 1000000):
    
    rng_returned = generate_rng()

    # Double check the return value.
    if rng_returned < 1 or rng_returned > 7:
        print ("Invalid value returned: %d" % (rng_returned))

    # Keep track of how many times each valiue is generated (use the value as
    # an index into the accumulator array.
    test_distribution[rng_returned - 1] = test_distribution[rng_returned - 1] + 1
    #print ("Calcuated RNG: %d" % (rng_returned))

print ("Value generated by index: ", test_distribution)
